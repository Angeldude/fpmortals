#+TITLE: Functional Programming in Scala for Mortals
#+AUTHOR: Sam Halliday
#+DATE: 2017

# https://lakshminp.com/publishing-book-using-org-mode
#+TAGS: ME OTHER
#+TODO: TODO | RESEARCH | NOTES | CHART | DIAGRAM | DRAWING | CODE | VIDEO
#+OPTIONS: toc:nil

* Frontmatter
:PROPERTIES:
:EXPORT_FILE_NAME: frontmatter.md
:END:
{frontmatter}

** Preface

This book is for Scala developers with an Object Oriented (OOP)
background who wish to learn the *Functional Programming* (FP)
paradigm.

Until now, Scala has lacked a practical introduction to FP. We do not
believe that learning Haskell should be a prerequisite. We also do not
accept that the merits of FP are obvious. Therefore, this book
justifies every concept with practical examples, in Scala.

We recommend [[https://www.manning.com/books/functional-programming-in-scala][The Red Book]] as optional further reading. It is a
textbook to learn the fundamentals and write your own FP library in
Scala, serving a different purpose than this book.

We also recommend [[http://haskellbook.com/][Haskell Programming from First Principles]] as
optional further reading. FP innovation has traditionally been in
Haskell because it is the academic standard. But Scala has gained much
more traction in industry and brings with it features, stability,
interop, powerful frameworks and a commercial ecosystem.

** Copyleft Notice

This book is *Libre* and follows the philosophy of [[https://www.gnu.org/philosophy/free-sw.en.html][Free Software]] for
books: you can use this book as you like, you can redistribute this
book and you can distribute your own version. That means you can print
it, photocopy it, e-mail it, post it on social media, upload it to
websites, change it, remix it, delete bits, and draw all over it. You
can even sell it.

This book is *Copyleft*: if you change the book and distribute your
own version, it must also pass on these freedoms to its recipients.

This book uses the [[https://creativecommons.org/licenses/by-sa/4.0/legalcode][Creative Commons Attribution ShareAlike 4.0
International]] (CC BY-SA 4.0) license.

In addition, all code examples in this book are [[https://www.apache.org/licenses/LICENSE-2.0][Apache 2.0]] licensed
and are not copyleft in their right.

** Thanks

Diego Esteban Alonso Blas, Raúl Raja Martínez and Peter Neyens of 47
degrees for their help with understanding the principles of FP, cats
and freestyle. Yi Lin Wei and Zainab Ali for their tutorials at Hack
The Tower meetups.

Juan Manuel Serrano for [[https://skillsmatter.com/skillscasts/9904-london-scala-march-meetup#video][All Roads Lead to Lambda]], Pere Villega for [[http://perevillega.com/understanding-free-monads][On
Free Monads]], Dick Wall and Josh Suereth for [[https://www.youtube.com/watch?v=WDaw2yXAa50][For: What is it Good For?]],
John de Goes for [[http://degoes.net/articles/easy-monads][A Beginner Friendly Tour]].

Those who helped explain concepts needed to write the example project
[[https://github.com/fommil/drone-dynamic-agents/issues?q=is%3Aissue+is%3Aopen+label%3A%22needs+guru%22][drone-dynamic-agents]]: Paul Snively.

The helpful souls on the [[https://gitter.im/typelevel/cats][cats]] chat room: Merlin Göttlinger, Edmund
Noble, Rob Norris, Adelbert Chang, Kai(luo) Wang.

The helpful souls on the [[https://gitter.im/functional-streams-for-scala/fs2][fs2]] chat room: Michael Pilquist, Adam
Chlupacek, Pavel Chlupacek.

** Practicalities

If you'd like to set up a project that uses the libraries presented in
this book, you will need to use a recent version of Scala with some
FP-specific features enabled (e.g. in =build.sbt=):

#+BEGIN_SRC scala
scalaVersion in ThisBuild := "2.12.1"
//scalaOrganization in ThisBuild := "org.typelevel"
scalacOptions in ThisBuild += "-Ypartial-unification"
#+END_SRC

and add the following dependencies to your project's settings:

#+BEGIN_SRC scala
libraryDependencies ++= Seq(
  "io.circe" %% "circe-core",
  "io.circe" %% "circe-generic",
  "io.circe" %% "circe-parser"
).map(_ % "0.7.0") ++ Seq(
  "org.typelevel" %% "cats"     % "0.9.0",
  "com.spinoco"   %% "fs2-http" % "0.1.6"
)

resolvers += Resolver.sonatypeRepo("snapshots")
addCompilerPlugin("org.scalamacros" %  "paradise"  % "2.1.0" cross CrossVersion.full)
libraryDependencies += "com.47deg"  %% "freestyle" % "0.1.0-SNAPSHOT"
#+END_SRC

In order to keep our snippets short, we will omit the =import=
section. Unless told otherwise, assume that all snippets have the
following imports:

#+BEGIN_SRC scala
import cats._
import cats.implicits._
import freestyle._
import freestyle.implicits._
#+END_SRC

* Mainmatter
:PROPERTIES:
:EXPORT_FILE_NAME: mainmatter.md
:END:
{mainmatter}

* Introduction                                                       :sample:
  :PROPERTIES:
  :EXPORT_FILE_NAME: introduction.md
  :END:
** Introduction

When hearing of a new paradigm, it is human instinct to be sceptical.
To put some perspective on how far we've come, and the paradigm shifts
we've adopted on the JVM, let's start with a quick recap of the last
25 years.

Java 1.2 introduced the Collections API, allowing us to write methods
that abstracted over mutable collections. It was useful for general
purpose algorithms and became a bedrock of business logic.

But there was a problem, we had to perform runtime casting:

#+BEGIN_SRC java
public String first(Collection collection) {
  return (String)(collection.get(0));
}
#+END_SRC

In response, developers defined domain objects that were effectively
=CollectionOfThings=, and the Collection API became implementation
detail.

In 2005, Java 5 introduced Generics, allowing us to define
=Collection<Thing>=, abstracting over the container and its elements.
Generics changed how we wrote Java.

Then Scala arrived with terse syntax and a fusion of object oriented
(OOP) and functional programming (FP). For most developers, FP means
using immutable data structures as much as possible, but mutable state
still needs to be managed by Akka. That's just the way applications
work: they need to keep track of some information that changes over
time.

Scala also brings =Future=, making it easy to write asynchronous
applications. But when a =Future= makes it into a return type,
/everything/ needs to be rewritten to accomodate it, including the
tests, which now are subject to arbitrary timeouts. We have a problem
similar to Java 1.0: there is no way of abstracting over execution,
much as we had no way of abstracting over collections.

*** Abstracting over Execution

Let's say we want to interact with the user over the command line
interface. We can =read= what the user types and we can =write= a
message to them.

#+BEGIN_SRC scala
trait TerminalSync {
  def read(): String
  def write(t: String): Unit
}

trait TerminalFuture {
  def read(): Future[String]
  def write(t: String): Future[Unit]
}
#+END_SRC

But how do we write generic code that does something as simple as echo
the user's input synchronously or asynchronously depending on our
runtime implementation?

We could write a synchronous version and wrap it with =Future= but now
we have to worry about which thread pool we should be using for the
work, or we could =Await.result= on the =Future= and introduce thread
blocking. In either case, it's a lot of boilerplate and we are
fundamentally dealing with different APIs that are not unified.

Let's try to solve the problem like Java 1.2 by introducing a common
parent. We use a feature of the scala type system that lets us
abstract over a type that takes a single type parameter. =C[_]= is
called a /type constructor/.

#+BEGIN_SRC scala
trait Terminal[C[_]] {
  def read: C[String]
  def write(t: String): C[Unit]
}
#+END_SRC

By definining =Now= to "construct to itself" we can now write
implementations of a common interface. If you need a word to associate
to =C=, /Context/ is a reasonable analogy because we can say =C= in
the context of =Future= or =C= in the context of =Now=.

#+BEGIN_SRC scala
type Now[+X] = X

object TerminalSync extends Terminal[Now] {
  def read: String = ???
  def write(t: String): Unit = ???
}

object TerminalFuture extends Terminal[Future] {
  def read: Future[String] = ???
  def write(t: String): Future[Unit] = ???
}
#+END_SRC

But the type =M= has no constraints, so if we get handed an
=C[String]= without knowing anything about =M= we can't do anything
with it. So we still can't write a generic =echo=.

Even though =Now= and =Future= don't share a common parent, we can take
a parameter to give us methods that we can call on =M=. What we need
is an execution environment with this signature:

#+BEGIN_SRC scala
trait Execution[C[_]] {
  def doAndThen[A, B](m: C[A])(f: A => C[B]): C[B]
  def returns[B](b: B): C[B]
}
#+END_SRC

letting us write (really ugly!) code like:

#+BEGIN_SRC scala
def echo[C[_]](t: Terminal[M], e: Execution[M]): C[String] =
  e.doAndThen(t.read) { in: String =>
    e.doAndThen(t.write(in)) { _: Unit =>
      e.returns(in)
    }
  }
#+END_SRC

which means we can now share the =echo= implementation between
synchronous and asynchronous codepaths! We only need to write an
implementation for =Execution[Now]= and =Execution[Future]= once and
we can reuse it forever. We can trivially write a mock implementation
of =Terminal[Now]= and use it in our tests.

But that syntax is horrible. Let's use the =implicit class= Scala
language feature (aka "enriching" or "ops") to make it look like =M=
has =Execution='s methods on it when there is an implicit =Execution=
available. Also, we'll call these methods =flatMap= and =map= for
reasons that will become clearer in a moment:

#+BEGIN_SRC scala
object Execution {
  implicit class Ops[A, C[_]](m: C[A])(implicit e: Execution[M]) {
    def flatMap[B](f: A => C[B]): C[B] = e.doAndThen(m)(f)
    def map[B](f: A => B): C[B] = e.doAndThen(m)(f andThen e.returns)
  }
}
#+END_SRC

cleaning up =echo= a little bit

#+BEGIN_SRC scala
def echo[C[_]](implicit t: Terminal[M], e: Execution[M]): C[String] =
  t.read.flatMap { in: String =>
    t.write(in).map { _: Unit =>
      in
    }
  }
#+END_SRC

we can now reveal why we used =flatMap= as the method name: it lets us
use the /for comprehension/ Scala language feature, which is just
syntax sugar to re-write nested calls to =flatMap= and =map=.

#+BEGIN_SRC scala
def echo[C[_]](implicit t: Terminal[M], e: Execution[M]): C[String] =
  for {
    in <- t.read
     _ <- t.write(in)
  } yield in
#+END_SRC

Now we admit that our =Execution= looks an awfully lot like a trait in
cats called =Monad=, which has more or less the same type signature.
We say that =C= is /monadic/ when there is an implicit =Monad[M]=
available. And our =Now= is more commonly known as =Id=.

The takeaway is: if we write methods that operate on monadic types,
then we can write procedural code that abstracts over its execution
context. Here, we've shown an abstraction over synchronous and
asynchronous execution but it can also be for the purpose of more
rigorous error handling (where =M[_]= is =Either[Error, _]=) or
recording / auditing of the session.

*** Pure Functional Programming

A pure FP language does not allow side effects: mutating state or
interacting with the world. But in Scala, we do this all the time. A
call to =println= will perform I/O (which is really hard to assert in
a test) and a call to =asString= on a =Http= instance will speak to a
web server. It's fair to say that typical Scala is *not* FP.

But something beautiful happened when we wrote our implementation of
=echo= --- it has no side-effects. Anything that interacts with the
world or mutates state is in the =Terminal= implementation. We are
free to implement =Terminal= without any interactions with a real
console, exactly what we want to do in our tests.

If we write our business logic using FP, we not only get to abstract
over the execution environment, but we also get to dramatically
improve the repeatability - and performance - of our tests.

Of course we cannot write an application devoid of interaction with
the world. In FP we push the code that deals with side effects to the
edges. That kind of code looks much like what you've been writing to
date, and can use battle tested libraries like NIO, Akka and Play.

This book expands on the style introduced in this chapter. Instead of
inventing any more primitives, we're going to use the traits and
classes defined in the /cats/ and /fs2/ libraries to implement pure FP
streaming applications. We'll also use the /freestyle/ and
/simulacrum/ developer tooling to eliminate boilerplate, allowing you
to focus on writing pure business logic.

* Main Text
  :PROPERTIES:
  :EXPORT_FILE_NAME: main-text.md
  :END:
** TODO =for=

We're going to be using these a lot. Need to be comfortable with it.

Include a lot of stuff from "For: what is it good for?"

** TODO Implicits

Perhaps need a refresher on how implicits work.

** TODO Example

Just the high level concepts. Ask the reader to suspend their belief
of =@free= and we'll explain what it's doing later, plus the algebraic
mixing.

And an =Id= based test to show that we can really write business logic
tests without a real implementation.

An architect's dream: you can focus on algebras, business logic and
functional requirements, and delegate the implementations to your
teams.

** TODO Pure business logic

(the cross-over from previous section is not yet clear)

We can define things that are like Java =interface=s, but with the
container and its implementation abstracted away, called an Algebra.

We can write all our business logic solely by combining these
algebras. If you ever want to call some code that can throw an
exception or speaks to the outside world, wrap it in an algebra so it
can be abstracted.

Everything can now be mocked, and we can write tests just of the
business logic.

Include some thoughts from [[http://degoes.net/articles/easy-monads][Beginner Friendly Tour]]

** RESEARCH Parallel work

Generating the initial state and https://github.com/fommil/drone-dynamic-agents/issues/6

Might require a moment to explain =FreeApplicative= (I'd rather not get into details yet).

** TODO Reality Check

- solved initial abstraction problem
- clean way to write logic and divide labour
- easier to write maintainable and testable code

Three steps forward but one step back: performance.

High level overview of what =@free= and =@module= is doing, and the
concept of trampolining. For a detailed explanation of free style and
the cats free monad implementation, see the appendix.

*** RESEARCH perf numbers
** TODO Typeclasses

look into the oauth / google / drone algebras as examples.

how cats uses typeclasses, e.g. to provide the =flatMap= on the free
monad and =|+|= on applicatives.

Discourage hierarchies except for ADTs

** TODO Cats
*** RESEARCH typeclasses

Foldable being imminently more interesting than the others.

Traversable will need to be discussed, seems to come up a lot.

*** RESEARCH data types

Not really sure what to say here.

** TODO Spotting patterns, refactoring

Note that some of our algebras are actually common things and can be
rewritten: reader / writer / state / error / indexed monad. It's ok
that this is a step you can do later.

These are called Effects.

** CODE FS2 Streams

The basics, and covering the Effect, which can be our free monad.

Why streams are so awesome. I'd like a simple example here of reading
from a huge data source, doing parallel work and then writing out in
order to a (slower) device to demonstrate backpressure and constant
memory overhead. Maybe compare this vs hand rolled and akka streams
for a perf test?

Rewrite our business logic to be streaming, convert our GET api into a
=Stream= by polling.

** RESEARCH Monad Transformers

Maybe too early? Let's say put it here if we need it for the
interpreters, otherwise after Optics.

** TODO interpreters

Show that although interpreters can be as messy as you like, you can
continue to write them as a pure core with side effects pushed to the
outside.

** TODO type refinement

instead of needing those =error= calls in the first place, just don't
allow them to happen at your layer if you can get away with it.

Protect yourself from mistyping

** RESEARCH Optics

not sure what the relevance to this project would be yet.

* Backmatter
:PROPERTIES:
:EXPORT_FILE_NAME: backmatter.md
:END:
{backmatter}
** TODO Free Implementation

detailed explanation about what =@free= / =@module= is generating and
how that feeds into the cats =Free= implementation.
** RESEARCH Tagless Final
